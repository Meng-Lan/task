思路：
1.读取，内存占用达到一定体积后，整体保存到外存，继续读取。
2.多路归并，指向一堆文件，并且提取最上面的一条加入比较，重复操作之后，得到最终有序的“URL 次数”的单文件。
3.读取一遍最后的文件，维护一下top100，得到结果。



1GB = 1024MB = 1048576KB


正常Tire: 1Node=128*4+8;
1GB<2M Node

左儿子/右兄弟Tire: 1Node=4+4+8+1=17;
1GB<60M Node

对于短字符串前缀大量重叠的情况，有用，但是长字符串，甚至前缀大量不重叠的短字符串情况，估计复杂度更差，可以卡到每次只处理2M/60M的字符，分出来的文件太多。


实际使用最傻的办法，每次读取512M字符，再用排序，写文件的时候顺带合并同类项。
试图写一个认为符合字符串排序方式的基数排序，即按位排序，从第一位开始按字符集大小sigma_size分成sigma_size堆，相对顺序不变，后每一堆又继续往下按相同的方式分，理论复杂度复杂度：以一对字符串用该方式排序，并设该对字符串长度为n，并且只在最后一个字符不同，则需要用的时间为n*sigma_size，因为考虑每一位都需要一次sigma_size的分堆操作。显然，对字符串集的排序，复杂度可以直接取上界为字符个数*sigma_size，天生自带大常数。
